/*
 * Auto-generated by CMake.
 * Do not modify or commit to source repository.
 */

#ifndef IFACELOG_UTIL_H
#define IFACELOG_UTIL_H

#include <Ice/Ice.h>
#include <iostream>

// namespace ${slice_module}ifacelog
namespace ifacelog
{

void toLogStream( bool x, std::ostream& os );
void toLogStream( Ice::Byte x, std::ostream& os );
void toLogStream( Ice::Short x, std::ostream& os );
void toLogStream( Ice::Int x, std::ostream& os );
void toLogStream( Ice::Long x, std::ostream& os );
void toLogStream( Ice::Float x, std::ostream& os );
void toLogStream( Ice::Double x, std::ostream& os );
void toLogStream( const std::string& x, std::ostream& os );

template<class E>
void seqToLogStream( const std::vector<E>& x, std::ostream& os )
{
    // save the number of elements in this sequence
    toLogStream( (Ice::Int)x.size(), os );
    // now save all elements of the sequence
    for ( size_t i=0; i<x.size(); ++i )
        toLogStream( x[i], os );
}

template<class K, class V>
void dictToLogStream( const std::map<K,V>& x, std::ostream& os )
{
    typedef typename std::map<K,V>::const_iterator KVConstIterator;

    // save the number of elements in this sequence
    toLogStream( (Ice::Int)x.size(), os );
    // now save all key/value pairs
    for ( KVConstIterator it=x.begin(); it!=x.end(); ++it ) {
        toLogStream( it->first, os );
        toLogStream( it->second, os );
    }
}

void fromLogStream( bool& x, std::istream& is );
void fromLogStream( Ice::Byte& x, std::istream& is );
void fromLogStream( Ice::Short& x, std::istream& is );
void fromLogStream( Ice::Int& x, std::istream& is );
void fromLogStream( Ice::Long& x, std::istream& is );
void fromLogStream( Ice::Float& x, std::istream& is );
void fromLogStream( Ice::Double& x, std::istream& is );
void fromLogStream( std::string& x, std::istream& is );

template<class E>
void seqFromLogStream( std::vector<E>& x, std::istream& is )
{
    // read the number of elements in this sequence
    size_t size;
    is >> size;
    // now read the sequence itself
    x.resize(size);
    for ( size_t i=0; i<size; ++i ) {
        // can't directly "fromLogStream(x[i],is)" here because it breaks for the stupid std::vector<bool>.
        E element;
        fromLogStream( element, is );
        x[i] = element;
    }
}

template<class K, class V>
void dictFromLogStream( std::map<K,V>& x, std::istream& is )
{
    // read the number of elements in this sequence
    size_t size;
    is >> size;
    // now read all key/value pairs
    x.clear();
    for ( size_t i=0; i<size; ++i ) {
        K key;
        V value;
        fromLogStream( key, is );
        fromLogStream( value, is );
        x[key] = value;
    }
}

}

#endif
