/*
 * Auto-generated by CMake.
 * Do not modify or commit to source repository.
 */

#ifndef IFACELOG_UTIL_H
#define IFACELOG_UTIL_H

#include <Ice/Ice.h>
#include <sstream>

// namespace ${slice_module}ifacelog
namespace ifacelog
{

void toLogString( bool x, std::stringstream& ss );
void toLogString( Ice::Byte x, std::stringstream& ss );
void toLogString( Ice::Short x, std::stringstream& ss );
void toLogString( Ice::Int x, std::stringstream& ss );
void toLogString( Ice::Long x, std::stringstream& ss );
void toLogString( Ice::Float x, std::stringstream& ss );
void toLogString( Ice::Double x, std::stringstream& ss );
void toLogString( const std::string& x, std::stringstream& ss );

// use only with std::vector's
template<class T>
void seqToLogString( const T& x, std::stringstream& ss )
{
    // save the number of elements in this sequence
    toLogString( (Ice::Int)x.size(), ss );
    // now save all elements of the sequence
    for ( size_t i=0; i<x.size(); ++i )
        toLogString( x[i], ss );
}

// use only with std::map's
template<class T, class Iterator>
void dictToLogString( const T& x, std::stringstream& ss )
{
    // save the number of elements in this sequence
    toLogString( (Ice::Int)x.size(), ss );
    // now save all key/value pairs
    for ( Iterator it=x.begin(); it!=x.end(); ++it ) {
        toLogString( it->first, ss );
        toLogString( it->second, ss );
    }
}

void fromLogString( bool& x, std::stringstream& ss );
void fromLogString( Ice::Byte& x, std::stringstream& ss );
void fromLogString( Ice::Short& x, std::stringstream& ss );
void fromLogString( Ice::Int& x, std::stringstream& ss );
void fromLogString( Ice::Long& x, std::stringstream& ss );
void fromLogString( Ice::Float& x, std::stringstream& ss );
void fromLogString( Ice::Double& x, std::stringstream& ss );
void fromLogString( std::string& x, std::stringstream& ss );

// use only with std::vector's
template<class E>
void seqFromLogString( std::vector<E>& x, std::stringstream& ss )
{
    // read the number of elements in this sequence
    size_t size;
    ss >> size;
    // now read the sequence itself
    for ( size_t i=0; i<size; ++i ) {
        E element;
        fromLogString( element, ss );
        x.push_back( element );
    }
}

// use only with std::map's
template<class K, class V>
void dictFromLogString( std::map<K,V>& x, std::stringstream& ss )
{
    // read the number of elements in this sequence
    size_t size;
    ss >> size;
    // now read all key/value pairs
    for ( size_t i=0; i<size; ++i ) {
        K key;
        V value;
        fromLogString( key, ss );
        fromLogString( value, ss );
        x[key] = value;
    }
}

}

#endif
