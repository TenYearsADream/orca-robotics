/*
 * Auto-generated by CMake.
 * Do not modify or commit to source repository.
 */

#ifndef IFACELOG_UTIL_H
#define IFACELOG_UTIL_H

#include <Ice/Ice.h>
#include <iostream>

// namespace ${slice_module}ifacelog
namespace ifacelog
{

void toLogStream( bool x, std::ostream& os );
void toLogStream( Ice::Byte x, std::ostream& os );
void toLogStream( Ice::Short x, std::ostream& os );
void toLogStream( Ice::Int x, std::ostream& os );
void toLogStream( Ice::Long x, std::ostream& os );
void toLogStream( Ice::Float x, std::ostream& os );
void toLogStream( Ice::Double x, std::ostream& os );
void toLogStream( const std::string& x, std::ostream& os );

// use only with std::vector's
template<class T>
void seqToLogStream( const T& x, std::ostream& os )
{
    // save the number of elements in this sequence
    toLogStream( (Ice::Int)x.size(), os );
    // now save all elements of the sequence
    for ( size_t i=0; i<x.size(); ++i )
        toLogStream( x[i], os );
}

// use only with std::map's
template<class T, class Iterator>
void dictToLogStream( const T& x, std::ostream& os )
{
    // save the number of elements in this sequence
    toLogStream( (Ice::Int)x.size(), os );
    // now save all key/value pairs
    for ( Iterator it=x.begin(); it!=x.end(); ++it ) {
        toLogStream( it->first, os );
        toLogStream( it->second, os );
    }
}

void fromLogStream( bool& x, std::istream& is );
void fromLogStream( Ice::Byte& x, std::istream& is );
void fromLogStream( Ice::Short& x, std::istream& is );
void fromLogStream( Ice::Int& x, std::istream& is );
void fromLogStream( Ice::Long& x, std::istream& is );
void fromLogStream( Ice::Float& x, std::istream& is );
void fromLogStream( Ice::Double& x, std::istream& is );
void fromLogStream( std::string& x, std::istream& is );

template<class E>
void seqFromLogStream( std::vector<E>& x, std::istream& is )
{
    // read the number of elements in this sequence
    size_t size;
    is >> size;
    // now read the sequence itself
    for ( size_t i=0; i<size; ++i ) {
        E element;
        fromLogStream( element, is );
        x.push_back( element );
    }
}

template<class K, class V>
void dictFromLogStream( std::map<K,V>& x, std::istream& is )
{
    // read the number of elements in this sequence
    size_t size;
    is >> size;
    // now read all key/value pairs
    for ( size_t i=0; i<size; ++i ) {
        K key;
        V value;
        fromLogStream( key, is );
        fromLogStream( value, is );
        x[key] = value;
    }
}

}

#endif
