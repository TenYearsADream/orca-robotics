/*
 * Auto-generated by CMake.
 * Do not modify or commit to source repository.
 */

#ifndef IFACESTRING_UTIL_H
#define IFACESTRING_UTIL_H

#include <string>

// namespace ${slice_module}ifacestring
namespace ifacestring
{

std::string toString( int x, int recurse=1000, int expand=-1, int indent=0 );

std::string toString( double x, int recurse=1000, int expand=-1, int indent=0 );

std::string toString( const std::string& x, int recurse=1000, int expand=-1, int indent=0 );

// use only with std::vector's
template<class T>
std::string
seqToString( const T& x, int recurse=1000, int expand=-1, int indent=0 )
{
    std::string s = "sequence (" + toString((int)x.size()) + ")";
    if ( expand )
    {
        std::string ind;
        for ( int i=0; i<indent; ++i )
            ind += ' ';

        size_t size = x.size();
        if ( expand>0 )
            size = expand;
        for ( size_t i=0; i<size; ++i )
            s += '\n' + ind + "[" + toString((int)i) + "]\t" + toString( x[i], recurse-1, expand, indent+2 );
    }
    return s;
}

// use only with std::map's
template<class T, class Iterator>
std::string
dictToString( const T& x, int recurse=1000, int expand=-1, int indent=0 )
{
    std::string s = "dictionary (" + toString((int)x.size()) + ")";
    if ( expand )
    {
        std::string ind;
        for ( int i=0; i<indent; ++i )
            ind += ' ';

        size_t i = 0;
        size_t size = x.size();
        if ( expand>0 )
            size = expand;
        for ( Iterator it=x.begin(); i<size; ++it ) {
            s += '\n' + ind + "[" + toString((int)i) + "]"
               + "\tkey = " + toString( it->first, recurse-1, expand, indent+2 )
               + "\tvalue = " + toString( it->second, recurse-1, expand, indent+2 );
            ++i;
        }
    }
    return s;
}

}

#endif
