/*
 * Auto-generated by CMake.
 * Do not modify or commit to source repository.
 */

#ifndef IFACESTRING_UTIL_H
#define IFACESTRING_UTIL_H

#include <string>

// namespace ${slice_module}ifacestring
namespace ifacestring
{

std::string toString( int x, bool expand=true, int indent=0 );

std::string toString( double x, bool expand=true, int indent=0 );

std::string toString( const std::string& x, bool expand=true, int indent=0 );

// use only with std::vector's
template<class T>
std::string
seqToString( const T& x, bool expand=true, int indent=0 )
{
    std::string s = "sequence (" + toString((int)x.size()) + ")";
    if ( expand )
    {
        std::string ind;
        for ( int i=0; i<indent; ++i )
            ind += ' ';

        for ( size_t i=0; i<x.size(); ++i )
            s += '\n' + ind + "[" + toString((int)i) + "]\t" + toString( x[i], expand, indent+2 );
    }
    return s;
}

// use only with std::map's
template<class T, class Iterator>
std::string
dictToString( const T& x, bool expand=true, int indent=0 )
{
    std::string s = "dictionary (" + toString((int)x.size()) + ")";
    if ( expand )
    {
        std::string ind;
        for ( int i=0; i<indent; ++i )
            ind += ' ';

        int count = 0;
        for ( Iterator it=x.begin(); it!=x.end(); ++it ) {
            s += '\n' + ind + "[" + toString(count) + "]"
               + "\tkey = " + toString( it->first, expand, indent+2 )
               + "\tvalue = " + toString( it->second, expand, indent+2 );
            ++count;
        }
    }
    return s;
}

}

#endif
