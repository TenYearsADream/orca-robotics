/*
 * Auto-generated by CMake.
 * Do not modify or commit to source repository.
 */

#ifndef IFACEUTIL_UTIL_H
#define IFACEUTIL_UTIL_H

#include <string>
#include <sstream>
#include <Ice/Ice.h>

// namespace ${slice_module}ifaceutil
namespace ifaceutil
{

std::string toString( bool x, int recurse=1000, int expand=-1, int indent=0 );
std::string toString( Ice::Byte x, int recurse=1000, int expand=-1, int indent=0 );
std::string toString( Ice::Short x, int recurse=1000, int expand=-1, int indent=0 );
std::string toString( Ice::Int x, int recurse=1000, int expand=-1, int indent=0 );
std::string toString( Ice::Long x, int recurse=1000, int expand=-1, int indent=0 );
std::string toString( Ice::Float x, int recurse=1000, int expand=-1, int indent=0 );
std::string toString( Ice::Double x, int recurse=1000, int expand=-1, int indent=0 );
std::string toString( const std::string& x, int recurse=1000, int expand=-1, int indent=0 );

template<class E>
std::string seqToString( const std::vector<E>& x, int recurse=1000, int expand=-1, int indent=0 )
{
    std::string s = "sequence (" + toString((int)x.size()) + ")";
    if ( expand )
    {
        std::string ind;
        for ( int i=0; i<indent; ++i )
            ind += ' ';

        size_t size = x.size();
        size_t skipped = 0;
        if ( expand>0 && (size_t)expand<size ) {
            size = (size_t)expand;
            skipped = x.size() - size;
        }

        for ( size_t i=0; i<size; ++i )
            s += '\n' + ind + "[" + toString((int)i) + "]\t" + toString( x[i], recurse-1, expand, indent+2 );

        if ( skipped ) {
            std::stringstream ss;
            ss << '\n' << ind << "[skipped " << skipped << " elements]";
            s += ss.str();
        }
    }
    return s;
}

template<class K, class V>
std::string dictToString( const std::map<K,V>& x, int recurse=1000, int expand=-1, int indent=0 )
{
    typedef typename std::map<K,V>::const_iterator KVConstIterator;

    std::string s = "dictionary (" + toString((int)x.size()) + ")";
    if ( expand )
    {
        std::string ind;
        for ( int i=0; i<indent; ++i )
            ind += ' ';

        size_t i = 0;
        size_t size = x.size();
        size_t skipped = 0;
        if ( expand>0 && (size_t)expand<size ) {
            size = (size_t)expand;
            skipped = x.size() - size;
        }

        for ( KVConstIterator it=x.begin(); i<size; ++it ) {
            s += '\n' + ind + "[" + toString((int)i) + "]"
               + "\tkey = " + toString( it->first, recurse-1, expand, indent+2 )
               + "\tvalue = " + toString( it->second, recurse-1, expand, indent+2 );
            ++i;
        }

        if ( skipped ) {
            std::stringstream ss;
            ss << '\n' << ind << "[skipped " << skipped << " pairs]";
            s += ss.str();
        }
    }
    return s;
}

/////////////////////////////////

void zeroAndClear( bool& x ); // { x = false; }

// void zeroAndClear( int8_t& x ) { x = 0; }
void zeroAndClear( Ice::Byte& x ); // { x = 0; }

// void zeroAndClear( int16_t& x ) { x = 0; }
void zeroAndClear( Ice::Short& x ); // { x = 0; }

// void zeroAndClear( int32_t& x ) { x = 0; }
void zeroAndClear( Ice::Int& x ); // { x = 0; }

// void zeroAndClear( int64_t& x ) { x = 0; }
void zeroAndClear( Ice::Long& x ); // { x = 0; }

void zeroAndClear( float& x ); // { x = 0.0; }

void zeroAndClear( double& x ); // { x = 0.0; }

void zeroAndClear( std::string& x ); // { x.clear(); }

void zeroAndClear( Ice::ObjectPrx& x ); // { x = 0; }

// use only with std::vector's
// template<class T>
// void seqZeroAndClear( T& x ) { x.clear(); }

// use only with std::map's
// template<class T>
// void dictZeroAndClear( T& x ) { x.clear(); }

}

#endif
