/*
 *  Orca Project: Components for robotics.
 *
 *  Copyright (C) 2004-2006
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

/*!

@page orca_doc_devcomp Developing Components

To reiterate, components can be developed in any way you choose.
   So long as they implement their interfaces, other components will
   be able to interoperate with them.  This page contains suggestions
   for how to think about components, and how to write them using
   libOrcaIceUtil.  Several of the components in the repository are
   designed in this way.

A basic component template looks like this:

@image html component_design.png

The main pieces are:

@par Component

Derives from orcaice::Component.

This the main class which instantiates and contains the other
pieces.  Deriving from orcaice::Component makes it easy to
exist within either a stand-alone application or an IceBox
Service.

To implement an orcaice::Component, the 'start()' and
    'stop()' functions must be implemented.

@par Interface Implementation
This class implements the methods defined in the Slice
interface definition, ie it does the talking to the outside world.
By convention, it it's named &lt;interface_name&gt;I and lives in
a file called &lt;interface_name&gt;_i.{h|cpp}.

Remote Method Invocations arrive asynchronously from the
outside world or from the Main Loop.  Requests from the outside
world can be answered using the information in the thread-safe
buffers.


@par Buffers
The buffers are instantiations of orcaice::PtrBuffer.
They're thread-safe (to handle the concurrency issues presented by
simultaneous access from MainLoop and the outside world), and
specially designed for Ice classes.


@par Main Loop

Most (but not all) components need to do some work
continuously.  MainLoop is the class that holds the thread of
execution (it derives from orcaice::Thread).

MainLoop's job is to be an intermediary between
Hardware/Algorithm and Interface_Implementation (via the Buffers).
A loop might look somthing like this (going vaguely clockwise in the figure):

    -# Check if new requests have arrived at the Buffers
    -# Hand the request(s) to the Hardware/Algorithm
    -# Read the data information generated by the Hardware/Algorithm (a blocking call)
    -# Send that data to the world via IceStorm
    -# Hand the data to the Buffers so the world can query it directly
    -# Goto step 1


@par Hardware/Algorithm

This is the part that actually does the work.  It may have its own internal threads.


The purpose of designing in this way is try to separate (a) network
communication, (b) sequence of control (including setup/shutdown,
component life-cycle), and (c) the algorithm or hardware driver itself.

*/
