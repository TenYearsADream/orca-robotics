<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" >
  <head>
        <title>ORCA Overview</title>
    <link rel="stylesheet" href="generic2.css" type="text/css" />
  </head>
    <body>

<!-- Do not edit or remove this line: it causes add_sidebar.pl to add the menu -->

      <p>&nbsp;</p>
<h1>Orca Overview</h1>

      <p>(Not yet converted to Orca2)</p>

      <p>This page gives a technical overview of Orca.  For a
      non-technical overview detailing information such as Orca's
      philosophy, history, and licensing, see the <a
      href="about.html">About</a> page.  For more detailed technical
      information, see the API documentation on Orca's <a
      href="objects/html/">Objects</a>, <a href="">Patterns</a>, <a
      href="components/html/">Components</a>.  For the real
      nitty-gritty, see the <a href="developers.html">Developers'
      Guide</a>.

<h2>Contents</h2>

      <ul>
        <li><a href="#systems">Systems of Interacting Components: An Overview</a></li>
        <li><a href="#clients">Clients and Servers</a></li>
        <li><a href="#elements">Elements of the Framework</a></li>
        <ul>
          <li><a href="#objects">Objects</a></li>
          <li><a href="#patterns">Interfaces</a></li>
          <li><a href="#transport">Ice as a Transport Mechanism</a></li>
          <li><a href="#components">Components</a></li>
        </ul>
        <li><a href="#connecting">Connecting Components</a></li>
        <li><a href="#putting">Putting It All Together</a></li>
      </ul>

      <h2><a name="systems">Systems of Interacting Components: An Overview</h2>

      <p>A component is a stand-alone process.  A system consists of a
      set of components which run asynchronously, passing objects to
      one another across well-defined interfaces.  Components don't
      know any of the details of any other components, they just
      provide certain object types and require certain object types.
      An example Orca system is shown below.
      </p>

      <img src="images/gorca_sample.png">

      <p>In this image, the small squares by which components are
      connected are called ports.  The only way to communicate with
      another component is through one of its ports.  

      <h2><a name="clients">Clients and Servers</h2>

      <p>The words 'client' and 'server' are used frequently, so they
      are worth defining.  The term 'client-server' implies a
      many-to-one relationship, and nothing more.  The terms 'client'
      and 'server' don't imply anything at all about the direction of
      information flow.</p>

      <p>The 'many' in 'many-to-one' can also be zero.  Thus a server
      can exist with zero clients, but a client needs exactly one
      server.</p>

      <h2><a name="elements">Elements of the Framework</h2>

      <p>The following elements of the Orca framework are important.
      Care has been taken to ensure that design decisions made about
      each element do not affect other elements.</p>

      <ol>
        <li><b>Objects</b>: the abstract definitions of the units of
        data that are passed (by value) between components. Examples
        include Point2D, Pose2D and LaserScan.</li>

        <li><b>Communication Patterns</b>: the abstract policies for
        how objects are sent between components.</li>

        <li><b>Transport Mechanism</b>: the method used to physically
        transport the objects, for example CORBA or raw TCP/IP. Each
        object's internal representation and each interface type must
        be implemented at most once for each language and transport
        mechanism. There is no requirement that all objects and
        patterns be implemented across all transport mechanisms: an
        incomplete set simply means that not all components are
        available for all transport mechanisms.</li>

        <li><b>Components</b>: The implementations of algorithms and
        servers for various types of hardware. The components can be
        implemented with knowledge only of the objects, the object
        methods, and the communication patterns. The transport
        mechanism is only relevant at compile-time. The implication of
        this is that the transport mechanism can be changed at
        compile-time.</li>
      </ol>

      <p>The number of possibilities for each of the items above is
      virtually infinite. Orca's approach is to define and implement
      the things which are most likely to be useful, while ensuring
      that the framework is flexible enough that any of the items
      above can be added to.  Users need only use the parts they like,
      and are free to make additions where they identify
      deficiencies.</p>

      <p>The four elements are described in further detail below.</p>

      <h2><a name="objects">Objects</h2>

      <p>An Object is something which can be passed (through a port)
      to other components.  It knows how to serialize itself ready for
      transmission to components running on other hosts, and it knows
      how to put itself back together on the other side (collectively
      known as marshaling and demarshaling).  It knows how to handle
      endian issues between hosts.  Some objects also have useful
      methods associated with them (such as adding two points).</p>

<!--
      <p>The abstract definitions of objects reside in
      <code>orca-base/src/objects</code>.  This directory contains a
      set of abstract classes prefixed with 'I'.  Each transport
      mechanism inherits from these classes and provides the
      representation and implementation.
      <code>orca-base/src/objects</code> also contains the
      implementations of objects' methods, which can often be written
      without knowledge of the implementation.</p>
-->

      <p>Since objects are the only common representation shared between
      components they should be thought out carefully.  A
      proliferation of subtly different objects hampers compatibility
      between components.</p>

      <p>For more detailed information, see <a
      href="objects/html/index.html">the Objects Documentation</a>.</p>

      
      <h2><a name="patterns">Communication Patterns</h2>

      <p>Communication patterns are used to define interfaces.</p>

      <p>In order for components to be replaceable, their interfaces
      must be very strictly defined.  Orca supports binary
      compatibility: one component of a system can be exchanged
      without having to compile anything else in the system.</p>

      <p>Components can only be connected across identical interfaces.
      The definitions of patterns, interfaces and ports might be a little
      confusing, so the definitions are followed by an example.</p>

      <h3><a name="definitions">Definitions</h3>

      <ul>
        <li><b>Communication Pattern</b>: an abstract policy for how
        objects are sent between components.</li>

        <li><b>Interface</b>: the combination of a communication
        pattern and an object type.</li>

        <li><b>Port</b>: An entity that implements a specific
        interface.  Implementing an interface may require a choice
        between additional parameters, such as the port's role in the
        pattern and how it deals with incoming objects.</li>
      </ul>

      <p>Ports are the local entities that components instantiate.
      Components deal with these ports instead of dealing with remote
      components directly, and therefore don't have to worry about
      things like network details.</p>

      <h3><a name="example">An Example</h3>

      <p>Consider the port
      '<code>ServerPush_Supplier&lt;Pose2D&gt;</code>'.  This port is
      used to send objects asynchronously to zero or more clients.
      Transfer is initiated by the server (the supplier of objects in
      this case).  This port type is made up of the following
      parts:</p>

        <TABLE CLASS="ex" cellSpacing=0 width="100%" border=1><TBODY><TR><TD><PRE>
<span CLASS="blue">ServerPush</span>_<span CLASS="red">Supplier</span>&lt;<span CLASS="orange">Pose2D</span>&gt;</PRE></TD></TR></TBODY></TABLE>

      <p>This port name has the following parts:</p>
      <ul>
        <li><span CLASS="blue">ServerPush</span>: This is the
        communication pattern, it defines how objects are sent.</li>

        <li><span CLASS="orange">Pose2D</span>: This is the object.
        This part defines what can be sent through this port.</li>

        <li>The interface is fully-defined by the two items above.</li>

        <li><span CLASS="red">Supplier</span>: This is the port's role
        in the pattern.  The combination of this role and the
        interface full-define this port.</li>
      </ul>
      </p>

      <p>As another examples, consider the port,
      '<code>ClientPush_ConsumerProxy&lt;Pose2D&gt;</code>'.  This port
      is used to set up an anonymous receiver, to which zero or more
      clients can send objects.  When objects are received the latest
      one is stored, such that the receiving component can retrieve
      them at its leisure.  This port type is made up of the following parts:</p>
      
        <TABLE CLASS="ex" cellSpacing=0 width="100%" border=1><TBODY><TR><TD><PRE>
<span CLASS="blue">ClientPush</span>_<span CLASS="red">ConsumerProxy</span>&lt;<span CLASS="orange">Point2D</span>&gt;</PRE></TD></TR></TBODY></TABLE>

      <p>This port name has the following parts:</p>
      <ul>
        <li><span CLASS="blue">ClientPush</span>: This is the
        communication pattern, it defines how objects are sent.</li>

        <li><span CLASS="orange">Point2D</span>: This is the object.
        This part defines what can be received through this port.</li>

        <li>The interface is fully-defined by the two items above.</li>

        <li><span CLASS="red">ConsumerProxy</span>: This defines both
        the port's role in the pattern and how it deals with incoming
        objects.  The combination of this role and the interface
        fully-define this port.</li>
      </ul>
      </p>

      <p>The abstract definitions of the ports reside in
      <code>orca-base/src/patterns</code>.  This directory contains a
      set of abstract classes prefixed with 'I'.  Each transport
      mechanism inherits from these classes and provides their
      implementations.  Templates are used to parameterize patterns
      over objects to produce interfaces.</p>
      
      <p>For more detailed information, see <a
      href="patterns/html/index.html">the Patterns
      Documentation</a>.</p>

      <p>In addition, there is <a
      href="examplecomponents/html/index.html">a working example for
      each of Orca's ports</a>.  See these examples for the details of
      how to instantiate them.</p>

      <h3>Some Patterns That Currently Exist</h3>

      <p>There are many possible way to classify communication patters. The picture
      below illustrates two axes: a) information flow and b) which sides triggers information
      transfer. In all four cases the topology is the same: one-to-many with the server on 
       the "one" side and the clients on the "many" side. When the supplier of information
      triggers the transmission, the pattern is commonly called a "push", otherwise it is
      called a "pull".</p>
      
          <img src="images/four_patterns.png">
      
      <p>In these unidirectional patterns, either port can take the
    role of either supplier or consumer of objects:</p>

      <ul>
       <li>For <emph>ServerPush</emph>, the
       ServerPush<emph>Supplier</emph> is the the <a
       href="#clients">server</a>, and the
       ServerPush<emph>Consumer</emph> is the <a
       href="#clients">client</a></li>

       <li>For <emph>ClientPush</emph>, the
       ServerPush<emph>Supplier</emph> is the the <a
       href="#clients">client</a>, and the
       ServerPush<emph>Consumer</emph> is the <a
       href="#clients">server</a></li>
      </ul>

      <p>A bi-directional 'bi-push' pattern has also been implemented.
      For a complete list of patterns, see <a
      href="patterns/html/index.html">the Patterns
      Documentation</a>.</p>


      <p>On the consumer side, the component may desire various types
      of behaviour when objects arrive:</p>

      <ul>
        <li><b>Notify</b>: The component should be alerted immediately.</li>

        <li><b>Proxy</b>: The incoming object should be stored for
        retrieval at the component's leisure.  When a new object
        arrive the previous object is over-written.</li>

        <li><b>Buffer</b>: When objects arrive they are stored in a
        buffer for retrieval at the component's leisure.  Since
        multiple objects can be stored, the component can be sure of
        not missing any incoming objects.</li>
      </ul>

      <h2><a name="transport">Transport Mechanism</h2>

      <p>Transport mechanisms provide the means for sending objects,
      connecting components, etc. Orca2 uses the Internet Communication Engine (Ice)
      for all its communication needs.</p>


      <h2><a name="components">Components</h2>

      <p>A component is nothing more than a process with a set of
      ports.</p>

      <p>The first thing a component should do when initializing is to
      read in its XML configuration file:</p>

      <TABLE CLASS="ex" cellSpacing=0 width="100%" border=1><TBODY><TR><TD><PRE>
    //
    // Get xml doc from command line
    //
    orca::XmlDoc xmlDoc( argc, argv );</PRE></TD></TR></TBODY></TABLE>

      <p>When the XmlDoc is instantiated, it is automatically <a
      href="xml_info.html">validated</a> against the component's <a
      href="xml_info.html">schema</a>, reducing the number of checks a
      component writer needs to do in code.</p>

      <p>For the rest of this example, assume that the xml file
      contains the following information:</p>

      <TABLE CLASS="ex" cellSpacing=0 width="100%" border=1><TBODY><TR><TD><PRE>
        &lt;client tag="laser"&gt;
            &lt;clientNameService nsPlatform="local" nsName="laserServer"/&gt;
        &lt;/client&gt;

        &lt;parameters myParam="0.5"/&gt;</PRE></TD></TR></TBODY></TABLE>

      <p>A component may want to read some of the parameters from its
      xml file, like so:</p>

      <TABLE CLASS="ex" cellSpacing=0 width="100%" border=1><TBODY><TR><TD><PRE>
    double myParamVal;
    double defaultValue = 5.0;
    xmlDoc.getParam( "myParam", myParamVal, defaultValue );</PRE></TD></TR></TBODY></TABLE>

      <p>Next, the component probably wants to instantiate some ports,
      in order to communicate with other components.  This is done
      with code similar to the following:</p>

      <TABLE CLASS="ex" cellSpacing=0 width="100%" border=1><TBODY><TR><TD><PRE>
    //
    // Client to receive pushed data
    //
    ServerPush_ConsumerProxy<orca::LaserScan> client;
    if ( client.setup( xmlDoc, "laser" ) != ORCA_SUCCESS )
    {
        cerr << "ERROR: Couldn't set up laser client" << endl;
        exit(1);
    }

    if ( client.connect() != ORCA_SUCCESS )
    {
        cerr << "ERROR: Couldn't connect to laser" << endl;
        exit(1);
    }</PRE></TD></TR></TBODY></TABLE>

      <p>This uses information from the XML file to configure the
      connection's endpoints, as described <a href="#connecting">
      below</a>.  For the example xml snippet above, the Naming
      service is used.</p>

      <p>Aside from this, components are pretty-much free to do
      whatever they like.</p>

      <p>For a complete listing of all Orca's components plus further
      information, see <a href="components/html/index.html">Components
      Documentation</a>.  For beginners, there are several simple <a
      href="examplecomponents/html/index.html">Example Components</a>.

      <h2><a name="connecting">Connecting Components</h2>

      <p>The topology of a system is configured using components' xml
      configuration files.</p>

      <p>Essentially each component's XML configuration file defines a
      set of ports and a set of parameters.  For each port, enough
      information must be supplied to allow ports to be connected.
      The format and content of this information will be different for
      each transport mechanism.  For details, see the documentation on
      <a href="#transport">Transport Mechanisms</a>.</p>

      <p>For more information about how the xml files are structured,
      see <a href="xml_info">the section on XML configuration file
      formats</a>.</p>

      <p>In principal there are various ways of specifying components'
      connections:</p>

      <ul>
        <li><b>Static Connections</b>: Using the transport mechanism's
        addressing scheme, inter-component connections can be stated
        explicitly in the components' xml files.  This might be done
        using raw IP addresses, Corba's Naming Service, etc, depending
        on the transport type.  This approach makes sense if there is
        a small number of components and complete control over the
        connections is desired.  This would be the case, for instance,
        when putting components together to build a single-vehicle
        architecture.</li>

        <li><b>Centralized Dynamic Connections</b>: If the exact
        topology is not as important as ensuring that all components
        have their requirements met, one could use a centralised
        trader to connect service providers with service consumers,
        where provided or required services are configured in the XML
        files.  This might be the case for larger-scale systems, where
        configuring connections by hand is tedious and/or
        inefficient.</li>

        <li><b>Decentralized Dynamic Connections</b>: In very large
        scale sensor networks, a centralized trader is both a
        bottleneck and a potential point of system-wide failure.  In
        this case components may need the ability to trade services
        directly.</li>

      </ul>
      
      <p>Currently, the only connection methods are:</p>

      <ul>
        <li><h4>Naming Service:</h4>

      <p>Each port (not component) registers its provided interfaces
      (ie servers) with a naming service.  When clients require those
      interface, they look them up by name to find the physical
      address.</p>

      <p>A service's name is made up of two parts:
      &lt;nsPlatform&gt;&lt;nsName&gt;</p>

      <p><b>nsPlatform</b>: Refers to the physical robot.  When robotA
      is run by many computers, setting the nsPlatform of all ports to
      'robotA' means that components on robotB needn't know how
      components are distributed over the computers making up robotA.
      Since robots are often controlled by a single computer,
      the special nsPlatform 'local' defaults to the hostname.</p>

      <p><b>nsName</b>: This is the name of the specific service on
      the robot.  The nsNames on a platform must be unique.</p>

        </li>

      </ul>

      <h2><a name="putting">Putting It All Together</h2>

      <p>When you have a set of components who have defined provided
      and required interfaces you'll want to connect them together
      into a working system.  Since it might not be clear yet what
      this would look like, here is an example system:</p>

      <img src="images/doc_sva.png">

      <p>This is a standard three-level architecture for a mobile
      robot.  On the bottom level a VFH+ component implements reactive
      obstacle avoidance.  On the top level a PathPlanner generates a
      list of waypoints in non-deterministic, unbounded time.  A GUI
      connects at any level of the hierarchy.  A localizer is
      responsible for keeping track of the robot's position.</p>

      <p>IMPORTANT: This is just one possibility (one of an infinite
      set) of Orca-based architectures for a single mobile robot.  It
      is included merely to help solidify the idea of piecing
      components together into a system.</p>

      <p>For practical information about putting a system together,
      see the <a href="tutorials.html">step-by-step tutorials</a>.</p>


<!-- Do not edit or remove this line: it causes add_sidebar.pl to add the footer -->

</body>
</html>
