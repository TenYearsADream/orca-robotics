/*
 *  Orca Project: Components for robotics.
 *
 *  Copyright (C) 2004-2006
 *
 *  This library is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  This library is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public
 *  License along with this library; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

/*!

@page orca_doc_walkthrough Writing Your First Orca2 Component
@author Waleed Kadous
@section intro Intro

This document will step you through the process of making your first
Orca2 component.  In particular, we will build an Orca2 component
called "drunkrobot" that simulates a robot that takes a random
walk. We'll use the existing Orca2 component "position2dmon" to watch
the robot as it moves around.

@section started Getting started

Before reading this document, you should familiarise yourself with: 
    - @ref orca_doc_getting : download, compile, install.
    - @ref orca_doc_quickstart : The Orca2 quick start guide.  
    - @ref orca_doc_devcomp : the basic Orca2 component design pattern

Once you've read that, things here should make a bit more sense. 

@section basics Basics

The @ref orca_doc_devcomp guide contains the following diagram that
will become the basis of our implementation. 

@image html component_design.png

Our design will be based on this sketch; beginning with the
implementation of the interface, then the main loop, then finallly the
component. We'll then actually get our component running, talking to
the Orca services and also to other components. 

@section interface Interface 

Our drunken robot must implement a particular interface. Let us assume
that our robot bumbles around on a flat surface. The appropriate
interface in this is case Position2d.  The Position2d data file is
declared in: src/interfaces/slice/orca/position2d.ice

From that declaration, which is written in Slice, a language for
describing object-oriented interfaces, we can see that our drunken
robot must implement the following methods:

@verbatim
interface Position2d
{
    nonmutating Position2dData getData();
    nonmutating Position2dGeometry getGeometry();
};
@endverbatim

 The "nonmutating" bit means that the ICE layer can make some
optimisations because getting data or geometry doesn't change our
drunken robot at all.

Note also that our robot must know about the Poisition2dData and
Position2dGeometry objects. These are also described in the ICE
file. Orca2 uses BROS (Basic Robotic Standard) for representations of
geometry and the like. These are also defined in the above file; for
instance, Position2dData:

@verbatim 
class Position2dData extends OrcaObject
{
    // Robot position
    Frame2d pose;
    // Translational and angular velocities in the robot CS
    Twist2d motion;
    // Are the motors stalled
    bool stalled;
};
@endverbatim

@section setup Setting up

For the moment, we'll be setting up in a subdirectory of the
src/examples, just to make building easier. But this doesn't have to
be this way. So first we go to src/examples, and make a new
directory called mydrunkrobot (a copy of all of the source code for
this walkthrough can be found in drunkrobot).

@verbatim
% mkdir mydrunkrobot
@endverbatim

@section interface Creating the interface classes

As discussed in the design pattern, our implementation of the interface simply takes puts things in 
a pointer buffer that our program then accesses in its main loop. Since we're implementing a 
position2d object, we need to create a simple implementation of the position2d object. We'll put 
this in a class called position2d_i. The file \c position2d_i.h looks like this:

\include ../src/examples/drunkrobot/position2d_i.h

After we include the header files, we then declare the
constructor. The first is a pointer to the 2d data, but set to use a
template of a Position2dData object, and the second, since it's not
going to change is the static 2d geometry.

The getData() and getGeometry() functions are also passed. Since it's ICE, some of the ICE state is 
also passed around. There are also members for the buffered results. 

No we implement the above interface. There's nothing unexpected here;
to get the latest position, we check the pointer buffer, to return the
configuration, we pass the value that was initialised when the
interface was created. The file \c position2d_i.cpp looks like this:

\include ../src/examples/drunkrobot/position2d_i.cpp

@section Creating the main loop. 

Now we've implemented the interface, we have to write the main loop
that actually does the processing. Main loops inherit from the
orcaice::Thread class. Because of this, it only need to implement
one method: run(). When run finishes, the thread will terminate. 

The other thing that's unusual about the main loop is that is also
responsible for "push" data. In Orca 2, data is pushed through
IceStorm, ICE's publish-subscribe system. This is done by using a
proxy for a consumer of Position2dData. We use the proxy (hence the
Prx) at the end to represent communication with IceStorm. 

Hence the file \c drunkrobotmainloop.h looks like this: 

\include ../src/examples/drunkrobot/drunkrobotmainloop.h 

The implementation is pretty simple as well. The constructor sets
things up. Then our main loop does the following: 

-# Make a new Position2dData object.
-# Use the orcaice method to set it to a sane value, which
   includes assigning random position values. 
-# Send it to IceStorm
-# Send it to the interface's pointer buffer so that if someone 
   does a getData() it returns the appropriate value. 
-# Sleep for a second.

The file \c drunkrobotmainloop.cpp is: 

\include ../src/examples/drunkrobot/drunkrobotmainloop.cpp

@section component Putting the component together 

The component glues the interface class and the main loop
together. Mostly, it is boiler-plate code; code that connects one
object to the other. The other important characteristic of the the
component is that it inherits from the orcaice::Component
class. This will allow us later to choose how we wish to run the
drunkrobot: as a stand-alone process or within what ICE calls an
IceBox -- an environment where lots of different components can live
and share resources more effectively than if they were separate
processes. 

The header for the component is as follows: 

\include ../src/examples/drunkrobot/drunkrobotcomponent.h

The implementation first appears to be intimidating, but if you do
find it intimidating, it might be worth reading through some examples
of how ICE sets up connections in the ICE manual. 

Our start() method basically does the following: 

-# Set up the geometry stuff so that it gets returned correctly 
-# Asks the communicator of this component to set up the port for our
   interface.
-# Attaches our implementation of the Position2d class to that port. 
-# Using a nice method in orcaice, sets up IceStorm output so that
   we can use the proxy to send out info to the proxy. 
-# activates the adapter for this component so that communication
can begin. 
-# Starts the main loop of our component. 

\include ../src/examples/drunkrobot/drunkrobotcomponent.cpp

@section build Setting up the build system. 

To build the software, we need to put together a CMakeLists.txt
file. As it turns out, we can use a generic one, for example, the one
that can be found in position2dmon. So you can copy the position2dmon
one and make some minor modifications as such (in CMakeLists.txt):

\include ../src/examples/drunkrobot/CMakeLists.txt

The next thing we have to do is go one level up to src/componenents
and modify the CMakeLists.txt file to include this subdirectory.

Finally, in the directory above mydrunkrobot, we do a cmake .; then a
make. We should now have a file called "drunkrobot"

@section config Setting up the Config files. 

We are almost there. Now we set up the config files for our robot. 

We need to specify the name of the platform, the component name and
finally that we plan to use the tcp protocol. Since we implement the
Position2d protocol, we specify the platform and component, and then 
the actual interface we implement. These all go in
drunkrobot.cfg: 

\include  ../src/examples/drunkrobot/drunkrobot.cfg

And finally we are ready! First, however, we have to launch the
support services, namely IceStorm and IcePack. In order to do this,
follow the instructions in @ref orca_doc_quickstart. 

Then all we have to type is: 

@verbatim
./drunkrobot
@endverbatim 

And we now have a robot that is generating random positions every 
second or so. 

@section position2dmon Connecting to another component. 

Let's now try to connect another component. Orca2 ships with
position2dmon, a command line tool for watching position2d objects,
just like our drunk robot. To get these two things to talk to one
another shouldn't be hard at all, in fact all it requires is to define
a new position2dmon config file. 

If we go into the position2dmon directory, we can create a file called
"position2dmon-drunkrobot.cfg". 

The contents of the file might be something like: 

@verbatim
# component
Position2dMon.PlatformName=local
Position2dMon.ComponentName=position2dmon
Position2dMon.Endpoints=default

# ports
Position2dMon.Requires.Position2d.PlatformName=local
Position2dMon.Requires.Position2d.ComponentName=drunkrobot
Position2dMon.Requires.Position2d.PortName=position2d
@endverbatim

In this section, we tell position2dmon where to look, in this case
drunk robot. 

Assuming that the drunkrobot process above is still running, we can
watch the position information using: 

@verbatim
./position2dmon --Ice.Config=position2dmon-drunkrobot.cfg"
@endverbatim

We can hit "g" to get the data once, or hit "s" to get a constant
stream of data. 

Woohoo! We now have two components talking to one another. 

@section furtherstuff Further things

There is still a little that you should learn about when using
Orca2. These include

- Putting components into IceBoxes instead of standalone
applications. 
- How to receive "pushed" messages using the orcaice::PtrNotify
class. 
- Documenting your code using the Doxygen system. 
- Implementing different interfaces in a single component. 
- Implementing synchronous processing calls. 

But ... that's the subject of another walkthrough. 

*/
